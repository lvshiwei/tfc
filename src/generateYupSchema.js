import * as t from '@babel/types';
import generate from '@babel/generator';
import { parse } from '@babel/parser';
import { isNotEmptyArray } from './lib/asserts';
import { JsonMockDescription } from './JsonMockDescription';
import {
  YUP_TYPE_STRING,
  YUP_TYPE_NUMBER,
  YUP_TYPE_BOOL,
  YUP_TYPE_DATE,
} from './constants';

const CODE_TEMPLATE = `
/**
* @overview A Yup schema generated by tfc.
*/
import { object, mixed, date, string, number, array } from "yup";

export default object();
`;
/**
 * generate yup schema code
 * @see ./JsonMockDescription.js
 * @param {JsonMockDescription} description json mock descripton object
 */
export default function (description) {
  const ast = parse(CODE_TEMPLATE, { sourceType: 'module' });
  const objectDeclaration = ast.program.body[1].declaration;

  const properties = [];
  for (const property of description.properties) {
    const rules = makeRule(property);
    properties.push(t.objectProperty(t.identifier(property.key), rules));
  }

  objectDeclaration.arguments.push(t.objectExpression(properties));

  const output = generate(ast, {}, CODE_TEMPLATE);
  const text = ensureReadableText(output.code);

  return text;
}

function makeRule(property) {
  if (isNotEmptyArray(property.annotations)) {
    return buildChainExpression(property.annotations, 0);
  }
}

function buildChainExpression(annotations, index) {
  if (annotations.length === 1 || index === annotations.length - 1) {
    const ann = annotations[index];

    return t.callExpression(t.identifier(ann.method), makeRuleArguments(ann));
  }

  const ann = annotations[index];
  return t.callExpression(
    t.memberExpression(
      buildChainExpression(annotations, index + 1),
      t.identifier(ann.method),
    ),
    makeRuleArguments(annotations[index]),
  );
}
/**
 * 构建规则参数
 */
function makeRuleArguments(annotation) {
  const params = annotation.getParameters();
  return params.map((p) => {
    const { type, value, raw } = p;
    switch (type) {
      case YUP_TYPE_STRING:
        return t.stringLiteral(value);
      case YUP_TYPE_NUMBER:
        return t.numericLiteral(value);
      case YUP_TYPE_BOOL:
        return t.booleanLiteral(value);
      case YUP_TYPE_DATE:
        return t.newExpression(t.identifier('Date'), [t.stringLiteral(raw)]);
      default:
        return t.stringLiteral(raw);
    }
  });
}

/**
 * 将unicode字符转化成可读的汉字
 * @param {*} unicodeText
 */
function ensureReadableText(unicodeText) {
  const r = /\\u([\d\w]{4})/gi;
  const dest = unicodeText.replace(r, function (match, grp) {
    return String.fromCharCode(parseInt(grp, 16));
  });
  return decodeURIComponent(dest);
}
