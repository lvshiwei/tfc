import * as t from "@babel/types";
import generate from "@babel/generator";
import { parse } from "@babel/parser";
import { LabelDescriptor } from "./TypeDescriptor";

export default function (schema) {
  const code = `
  /**
   * @overview A form component generated by tfc.
   * @author your.name@corp.com
   */
  import React from "react";
  import classnames from "classnames";
  import schema from "./schema";
  import { useModel, useValidation } from "./hooks";
  import { Card, List, InputItem, Picker, DatePicker } from "antd-mobile";

  /**
   * Say something to avoid warnning from eslint
   */
  export default function () {
    const [model, setModel] = useModel({ preOpeningTime: new Date() });
    const [validate, errors] = useValidation(schema);
  
    const handleSubmit = () =>
      validate(model)
        .then(() => alert("Amazing!!"))
        .catch(console.error);
  
    const handleInputChange = (name) => (value) => setModel(name, value);
    const handleLeaveInput = (name) => () => validate(name, model[name]);
    const handleSelectChange = (name) => (value) => {
      setModel(name, value);
      validate(name, value);
    };
    const renderClassName = (name, properties) =>
      classnames(...(properties || []), {
        error: Array.isArray(errors) && errors.some((e) => e.path === name),
        hasValue: !(model[name] === null || typeof model[name] === "undefined"),
      });

    const Required = () => <i className="required">*</i>;
  }`;
  const ast = parse(code, { sourceType: "module", plugins: ["jsx"] });
  const exportDefault = ast.program.body.find(t.isExportDefaultDeclaration);

  const newline = t.jsxText("\n");
  const div = t.jsxIdentifier("div");
  const divOpen = t.jsxOpeningElement(div, []);
  const divClose = t.jsxClosingElement(div);
  const list = t.jsxIdentifier("List");
  const listComp = t.jsxElement(
    t.jsxOpeningElement(list, []),
    t.jsxClosingElement(list),
    [newline]
  );
  for (const key in schema) {
    const item = t.jsxIdentifier("InputItem");
    const itemComp = t.jsxElement(
      t.jsxOpeningElement(item, [
        t.jsxAttribute(t.jsxIdentifier("name"), t.stringLiteral(key)),
        t.jsxAttribute(
          t.jsxIdentifier("onChange"),
          t.jsxExpressionContainer(
            t.callExpression(t.identifier("handleChangeInput"), [
              t.stringLiteral(key),
            ])
          )
        ),
      ]),
      t.jsxClosingElement(item),
      []
    );
    const rules = schema[key];
    const labelDesc = schema[key].find((i) => i instanceof LabelDescriptor);
    if (labelDesc) {
      itemComp.children.push(t.jsxText(labelDesc.value));
    }
    const typeDesc = rules.slice(-1)[0];
    if (["string", "number"].includes(typeDesc.name)) {
      itemComp.openingElement.attributes.push(
        t.jsxAttribute(
          t.jsxIdentifier("onBlur"),
          t.jsxExpressionContainer(
            t.callExpression(t.identifier("handleLeaveInput"), [
              t.stringLiteral(key),
            ])
          )
        )
      );
    }
    const isRequired = rules.some((r) => r.name === "required");
    if (isRequired) {
      itemComp.children.push(
        t.jsxElement(
          t.jsxOpeningElement(t.jsxIdentifier("Required"), [], true),
          null,
          [],
          true
        )
      );
    }

    listComp.children.push(itemComp);
    listComp.children.push(newline);
  }

  const jsxroot = t.jsxElement(divOpen, divClose, [newline, listComp, newline]);

  const returnStatement = t.returnStatement(jsxroot);
  exportDefault.declaration.body.body.push(returnStatement);
  const output = generate(ast, {}, code);

  return output.code;
}
