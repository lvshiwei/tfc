/**
 * @overview generate form code from schema description object
 * @see ./SchemaDescription.js
 * @author shiwei.lv
 */

import * as t from '@babel/types';
import generate from '@babel/generator';
import { parse } from '@babel/parser';
import { YUP_TYPE_LIST, YUP_TYPE_DATE } from './constants';
import { isNotEmptyString } from './lib/asserts';

const CODE_TEMPLATE = `
/**
 * @overview A form component generated by tfc.
 * @author your.name@corp.com
 */
import React from "react";
import classnames from "classnames";
import schema from "./schema";
import { useModel, useValidation } from "fooky";
import { List, InputItem, Picker, DatePicker } from "antd-mobile";

/**
 * Say something to avoid warnning from eslint
 */
export default function () {
  const [model, setModel] = useModel({});
  const {validate, hasError} = useValidation(schema);

  const handleSubmit = () =>
    validate(model)
      .then(() => alert("Amazing!!"))
      .catch(console.error);

  const handleChangeInput = (name) => (value) => setModel(name, value);
  const handleLeaveInput = (name) => () => validate(name, model[name]);
  const handleChangeSelect = (name) => (value) => {
    setModel(name, value);
    validate(name, value);
  };
  const renderClassName = (name, properties) =>
    classnames(...(properties || []), {
      error: hasError(name),
      hasValue: !(model[name] === null || typeof model[name] === "undefined"),
    });

  const Required = () => <i className="required">*</i>;

  return <div className="form-wrapper"></div>;
}`;
const NEWLINE = t.jsxText('\n');

export default function (description) {
  const ast = parse(CODE_TEMPLATE, { sourceType: 'module', plugins: ['jsx'] });
  const exportDefault = ast.program.body.find(t.isExportDefaultDeclaration);
  const returnStatement = exportDefault.declaration.body.body.find(
    t.isReturnStatement,
  );
  const divElement = returnStatement.argument;

  divElement.children.push(NEWLINE);
  const fieldset = t.jsxElement(
    t.jsxOpeningElement(t.jsxIdentifier('List'), []),
    t.jsxClosingElement(t.jsxIdentifier('List')),
    [NEWLINE],
  );

  for (const rule of description.rules) {
    fieldset.children.push(makeField(rule));
    fieldset.children.push(NEWLINE);
  }
  divElement.children.push(fieldset);
  divElement.children.push(NEWLINE);
  divElement.children.push(makeSubmitButton());
  const output = generate(ast, {}, CODE_TEMPLATE);

  return output.code;
}

function makeField(ruleDescriptor) {
  const dataType = ruleDescriptor.dataType;

  if (!YUP_TYPE_LIST.includes(dataType)) {
    return t.jsxEmptyExpression();
  }

  if (dataType === YUP_TYPE_DATE) {
    return makeDatePicker(ruleDescriptor);
  } else {
    return makeInputItem(ruleDescriptor);
  }
}

function makeRequiredElement() {
  return t.jsxElement(
    t.jsxOpeningElement(t.jsxIdentifier('Required'), [], true),
    null,
    [],
    true,
  );
}

function makeRenderClassAttribute(name) {
  return t.jsxAttribute(
    t.jsxIdentifier('className'),
    t.jsxExpressionContainer(
      t.callExpression(t.identifier('renderClassName'), [
        t.stringLiteral(name),
      ]),
    ),
  );
}

function makeDatePicker(ruleDescriptor) {
  const { name } = ruleDescriptor;
  const picker = t.jsxIdentifier('DatePicker');
  const item = t.jsxIdentifier('List.Item');

  return t.jsxElement(
    t.jsxOpeningElement(picker, [
      t.jsxAttribute(t.jsxIdentifier('mode'), t.stringLiteral('date')),
      t.jsxAttribute(
        t.jsxIdentifier('onChange'),
        t.jsxExpressionContainer(
          t.callExpression(t.identifier('handleSelectChange'), [
            t.stringLiteral(name),
          ]),
        ),
      ),
    ]),
    t.jsxClosingElement(picker),
    [
      NEWLINE,
      t.jsxElement(
        t.jsxOpeningElement(item, [
          t.jsxAttribute(
            t.jsxIdentifier('arrow'),
            t.stringLiteral('horizontal'),
          ),
          makeRenderClassAttribute(name),
        ]),
        t.jsxClosingElement(item),
        makeLabelAndRequired(ruleDescriptor),
      ),

      NEWLINE,
    ],
  );
}

function makeInputItem(ruleDescriptor) {
  const { name } = ruleDescriptor;
  const inputItem = t.jsxIdentifier('InputItem');
  return t.jsxElement(
    t.jsxOpeningElement(inputItem, [
      makeRenderClassAttribute(name),
      t.jsxAttribute(
        t.jsxIdentifier('onChange'),
        t.jsxExpressionContainer(
          t.callExpression(t.identifier('handleInputChange'), [
            t.stringLiteral(name),
          ]),
        ),
      ),
      t.jsxAttribute(
        t.jsxIdentifier('onBlur'),
        t.jsxExpressionContainer(
          t.callExpression(t.identifier('handleLeaveInput'), [
            t.stringLiteral(name),
          ]),
        ),
      ),
    ]),
    t.jsxClosingElement(inputItem),
    makeLabelAndRequired(ruleDescriptor),
  );
}

function makeLabelAndRequired(ruleDescriptor) {
  const { label, isRequired } = ruleDescriptor;

  const children = [];
  if (isNotEmptyString(label)) {
    children.push(t.jsxText(label));
  }
  if (isRequired === true) {
    children.push(makeRequiredElement());
  }
  return children;
}

function makeSubmitButton() {
  const button = t.jsxIdentifier('Button');
  return t.jsxElement(
    t.jsxOpeningElement(button, [
      t.jsxAttribute(
        t.jsxIdentifier('onClick'),
        t.jsxExpressionContainer(t.identifier('handleSubmit')),
      ),
    ]),
    t.jsxClosingElement(button),
    [t.jsxText('submit')],
  );
}
