/**
 * @overview generate form code from schema description object
 * @see ./SchemaDescription.js
 * @author shiwei.lv
 */

import * as t from '@babel/types';
import generate from '@babel/generator';
import { parse } from '@babel/parser';
import { YUP_TYPE_LIST, YUP_TYPE_DATE } from './constants';

const CODE_TEMPLATE = `
/**
 * @overview A form component generated by tfc.
 * @author your.name@corp.com
 */
import React from "react";
import classnames from "classnames";
import schema from "./schema";
import { useModel, useValidation } from "./hooks";
import { List, InputItem, Picker, DatePicker } from "antd-mobile";

/**
 * Say something to avoid warnning from eslint
 */
export default function () {
  const [model, setModel] = useModel({ preOpeningTime: new Date() });
  const [validate, errors] = useValidation(schema);

  const handleSubmit = () =>
    validate(model)
      .then(() => alert("Amazing!!"))
      .catch(console.error);

  const handleChangeInput = (name) => (value) => setModel(name, value);
  const handleLeaveInput = (name) => () => validate(name, model[name]);
  const handleChangeSelect = (name) => (value) => {
    setModel(name, value);
    validate(name, value);
  };
  const renderClassName = (name, properties) =>
    classnames(...(properties || []), {
      error: Array.isArray(errors) && errors.some((e) => e.path === name),
      hasValue: !(model[name] === null || typeof model[name] === "undefined"),
    });

  const Required = () => <i className="required">*</i>;

  return <div className="form-wrapper"></div>;
}`;

export default function (description) {
  const ast = parse(CODE_TEMPLATE, { sourceType: 'module', plugins: ['jsx'] });
  const exportDefault = ast.program.body.find(t.isExportDefaultDeclaration);
  const returnStatement = exportDefault.declaration.body.body.find(
    t.isReturnStatement,
  );
  const divElement = returnStatement.argument;

  divElement.children.push(newline);
  const newline = t.jsxText('\n');
  const fields = t.jsxElement(
    t.jsxOpeningElement(t.jsxIdentifier('List'), []),
    t.jsxClosingElement(t.jsxIdentifier('List')),
    [newline],
  );

  for (const rule in description.rules) {
    fields.children.push(makeField(rule));
  }
  divElement.children.push(newline);
  const output = generate(ast, {}, CODE_TEMPLATE);

  return output.code;
}

function makeField(ruleDescriptor) {
  const dataType = ruleDescriptor.dataType;

  if (!YUP_TYPE_LIST.includes(dataType)) {
    return t.jsxEmptyExpression();
  }

  if (dataType === YUP_TYPE_DATE) {
    return makeDatePicker(ruleDescriptor);
  } else {
    return makeInputItem(ruleDescriptor);
  }
}

function makeRequiredElement() {
  return t.jsxElement(
    t.jsxOpeningElement(t.jsxIdentifier('Required'), [], true),
    null,
    [],
    true,
  );
}

function makeRenderClassAttribute(name) {
  return t.jsxAttribute(
    t.jsxIdentifier('className'),
    t.jsxExpressionContainer(
      t.callExpression(t.identifier('renderClassName'), [
        t.stringLiteral(name),
      ]),
    ),
  );
}

function makeDatePicker(ruleDescriptor) {
  const { name, label, isRequired } = ruleDescriptor;
  const picker = t.jsxIdentifier('DatePicker');
  const item = t.jsxIdentifier('List.Item');

  return t.jsxElement(
    t.jsxOpeningElement(picker, [
      t.jsxAttribute(t.identifier('mode'), t.stringLiteral('date')),
      t.jsxAttribute(
        t.identifier('onChange'),
        t.jsxExpressionContainer(
          t.callExpression(t.identifier('handleSelectChange'), [
            t.stringLiteral(name),
          ]),
        ),
      ),
    ]),
    t.jsxClosingElement(picker),
    [
      t.jsxElement(
        t.jsxOpeningElement(item, [
          t.jsxAttribute(t.identifier('arrow'), t.stringLiteral('horizontal')),
          makeRenderClassAttribute(name),
        ]),
        t.jsxClosingElement(item),
        [
          t.jsxText(label),
          isRequired === true ? makeRequiredElement() : t.jsxEmptyExpression(),
        ],
      ),
    ],
  );
}

function makeInputItem(ruleDescriptor) {
  const { name, label, isRequired } = ruleDescriptor;
  const inputItem = t.jsxIdentifier('InputItem');
  return t.jsxElement(
    t.jsxOpeningElement(inputItem, [
      makeRenderClassAttribute(name),
      t.jsxAttribute(
        t.jsxIdentifier('onChange'),
        t.jsxExpressionContainer(
          t.callExpression(t.identifier('handleInputChange'), [
            t.stringLiteral(name),
          ]),
        ),
      ),
      t.jsxAttribute(
        t.jsxIdentifier('onBlur'),
        t.jsxExpressionContainer(
          t.callExpression(t.identifier('handleLeaveInput'), [
            t.stringLiteral(name),
          ]),
        ),
      ),
    ]),
    t.jsxClosingElement(inputItem),
    [
      t.jsxText(label),
      isRequired === true ? makeRequiredElement() : t.jsxEmptyExpression(),
    ],
  );
}
